# app/routers/orders.py
from fastapi import APIRouter, Depends, WebSocket, WebSocketDisconnect
from sqlalchemy.orm import Session
from .. import models, schemas, db, realtime

router = APIRouter(prefix="/orders", tags=["Orders"])

# Create order
@router.post("/", response_model=schemas.OrderOut)
def create_order(order: schemas.OrderCreate, session: Session = Depends(db.SessionLocal)):
    new_order = models.Order(
        customer_name=order.customer_name,
        table_number=order.table_number,
        phone=order.phone,
        email=order.email,
        note=order.note,
        mode=order.mode,
        status="pending"
    )
    session.add(new_order)
    session.commit()
    session.refresh(new_order)

    # TODO: Save order items separately in OrderItem model (loop over order.items)
    # For now we just broadcast summary
    total = sum([item.qty * session.query(models.MenuItem).get(item.menu_item_id).price for item in order.items])

    import asyncio
    asyncio.create_task(realtime.order_manager.broadcast({
        "type": "order",
        "id": new_order.id,
        "customer_name": new_order.customer_name,
        "status": new_order.status,
        "total": total,
        "created_at": str(new_order.created_at),
    }))

    return schemas.OrderOut(
        id=new_order.id,
        customer_name=new_order.customer_name,
        status=new_order.status,
        total=total,
        created_at=new_order.created_at
    )

# WebSocket for live orders
@router.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await realtime.order_manager.connect(websocket)
    try:
        while True:
            await websocket.receive_text()  # Keep connection alive
    except WebSocketDisconnect:
        realtime.order_manager.disconnect(websocket)